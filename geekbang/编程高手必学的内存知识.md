# 编程高手必学的内存知识

----

## 开篇词

### 开篇词｜为什么你要系统学习计算机内存知识？





## 课程导学

### 导学（一）｜拆解CPU的基本机构和运行原理







### 导学（二）｜汇编语言是怎么一回事？







### 导学（三）｜一个CPU是怎么寻址的？







## 软件篇

### 01｜虚拟内存：为什么可用内存会远超物理内存？



### 02｜**聊聊**x86体系架构中的实模式和保护模式

**实模式**：在内存管理上使用的是直接访问物理内存的工作方式，就叫做实模式；

**保护模式**：在CPU上出现虚拟内存的概念后，把这种利用虚拟内存进行操作的模式叫做保护模式，也就是不直接操作实际内存。

#### 8086中的实模式

在实模式下，程序员是不能通过内存管理单元MMU访问地址的，程序必须直接访问物理内存。

在实模式下，如何访问物理地址？

**物理地址 = 段寄存器 << 4 + 段内偏移**

逻辑地址：包含了段基址和段内偏移值的地址形式叫做逻辑地址。

#### i386中的保护模式

##### 变化一：段选择子和全局描述符表

<img src="https://cdn.jsdelivr.net/gh/Mark-Jackson-Github/images@master/uPic/JZ2tyCerHDUlObM.png" alt="image-20220113213235777.png" style="zoom:50%;" />

GDT：全行业描述表，本质上就是一个数组，其中的每一项都是一个全局描述表，32位的段基址就存储在这个描述符里。

**由CPU的MMU将线性地址映射为物理地址，后可以交给地址总线去进行读写了**

##### 变化二：段寄存器对段的保护能力增强

<img src="https://cdn.jsdelivr.net/gh/Mark-Jackson-Github/images@master/uPic/KerlXLbaVFHWcEh.png" alt="image-20220113214213480.png" style="zoom:50%;" />

##### 段式管理对比页式管理

段式管理将内存空间分为：代码段、数据段、只读数据段、堆栈段等等。不同段会有不同的读写权限。通过段式管理可以进一步区分内核数据段、内核代码段、用户态数据段、用户态代码段等。

**相比于页式管理，段式管理的优点是提供更好的安全性，按照内存的用途进行划分更符合直观思维。缺点：不定长，难于进行分配、回收调度。**

##### 中断描述符表

IDT：是i386中一个非常重要的描述符表，它也是保护模式对比实模式的另一大不同。**中断描述的作用就体现在其本质就是中断描述符的数组。**

<img src="https://cdn.jsdelivr.net/gh/Mark-Jackson-Github/images@master/uPic/BWPvgQJaEUFLVyx.png" alt="image-20220113224313039.png" style="zoom:50%;" />

##### 总结

8086的工作模式是实模式，特点是直接操作物理内存，内存管理容易出错，需要十分小心，代码编写和调试都很困难。

i386采用保护模式，采用了段页式混合管理模式。

----



### 03｜内存布局：应用程序是如何安排数据的？

##### 抽象内存布局

一个程序的机器码会被组织到同一个地方，这个地方就是**代码段**。

程序操作的数据会被放到程序的二进制文件中，这些数据部分也会被装载到内存中，也就是程序的**数据段**。

<img src="https://cdn.jsdelivr.net/gh/Mark-Jackson-Github/images@master/uPic/XTdNwZUYoEDiR1l.png" alt="image-20220113232934600.png" style="zoom:30%;" />

除了以上的基本内存之外，现代应用程序中还会包含其他一些内存区域：

* 存放加载的共享库的内存空间：如果一个进程以来共享库，那对应的，该共享库的代码段、数据段、BSS段也需要加载到这个进程的地址空间中；
* 共享内存段：我们可以通过系统调用映射一块匿名区域作为共享内存，用来进行进程间通信；
* 内存映射文件：我们可以将磁盘的文件映射到内存中，用来进行文件编译或者类似共享内存的方式进行进程通信。

<img src="https://cdn.jsdelivr.net/gh/Mark-Jackson-Github/images@master/uPic/RrmCpGLX7yfiNkA.png" alt="image-20220113233355797.png" style="zoom:50%;" />

*左边的是程序在磁盘中的文件布局结构，右边是程序加载到内存中内存布局结构。*

**Section主要是指在磁盘中的程序段，而Segment则用来指代内存中的程序段，Segment是将具有相同权限属性的Section集合在一起，系统为他们分配一块内存空间。**

**IA-32机器上的Linux进程内存局部**

<img src="https://cdn.jsdelivr.net/gh/Mark-Jackson-Github/images@master/uPic/uxygPfOitrzmEZw.png" alt="image-20220114084100093.png" style="zoom:50%;" />

**每次在进程向内核申请新的堆地址的时候，其他地址的值在增大**。在之对应的是栈空间，有一个向下的箭头，说明栈增长的方向是向低地址方向增长，也就是说，每次进程申请新的栈地址时，其地址值是在减少的。

**intel64机器上的linux进程内存布局**

<img src="https://cdn.jsdelivr.net/gh/Mark-Jackson-Github/images@master/uPic/tfsHNpb6MlegkYo.png" alt="image-20220114111620238.png" style="zoom:50%;" />

**申请堆空间**

不管是32位还是64位系统，内核都会维护一个brk变量，**brk的位置实际上就是决定了堆的大小。**

1. sbr通过给内核的brk变量增加incr，来改变堆的大小，incr可以位负数。
2. mmp

```c
 #include <unistd.h> 
 #include <sys/mman.h>

void* mmap(void* start, size_t length, int prot, int flags, int fd, off_t offset);
```

* start代表该区域的起始地址；
* length代表该区域的长度；
* pro描述了这块新的内存区域的访问权限；
* flags描述了该区域的类型；
* fd代表文件描述符；
* offset代表文件内的偏移值。

mmap的功能非常强大，根据参数不同，他可以用于创建共享内存，也可以创建文件映射区域用于提升IO效率，还可以用来申请堆内存。决定它的功能的，主要port，flags和fd这三个参数。

port的值可以是以下四个常量组合：

* PROT_EXEC，表示这块内存区域由可执行权限，意味着这部分内存可以看成是代码段，它里边存储的往往是CPU可以执行的机器码；
* PROT_READ，表示这块内存区域可读；
* PROT_WRITE，表示这块内存区域可写；
* PROT_NONE，表示这块内存区域的页面不能被访问。

man mmap查看，四种可取值常量：

* MAP_SHARED：创建以恶搞共享映射的区域，多个进程可以通过共享映射的方式，来共享一个文件，这样一来，一个进程对该文件的修改，其他进程也可以观察到，这就实现可数据的通讯；
* MAP_PRIVATE：创建一个私有的映射区域，多个进程可以使用私有映射的方式，来映射同一个文件。但是，当一个进程对文件进行修改时，操作系统机会为他创建一个独立副本，这样它对文件的修改，其他进程就看不到了，从而达到映射区域私有的目的。
* MAP_ANONYMOUS：创建一个匿名映射，也就是没有关联文件。使用这个选项时，fd参数必须为空。
* MAP_FIFED：addr参数知识建议操作系统尽量以addr为起始地址进行内存映射，但是如果操作系统判断addr作为起始地址不能满足长度或者权限要求时，就会另外再找其他合适的区域进行映射。如果flags的值取值是MAP_FIXED的话。就不再把addr看成建议，而是将其视为强制要求。如果不能成功映射，就会返回空指针。

**mmap的其他应用场景**

<img src="https://cdn.jsdelivr.net/gh/Mark-Jackson-Github/images@master/uPic/008i3skNly1gyd62tni71j30sy0h440e.jpg" style="zoom:50%;" />



```c
#include <sys/mman.h> 
#include <stdlib.h> 
#include <stdio.h> 
#include <unistd.h>

int main() { 
  pid_t pid;
	char* shm = (char*)mmap(0, 4096, PROT_READ | PROT_WRITE, 
                          MAP_SHARED | MAP_ANONYMOUS, -1, 0);

	if (!(pid = fork())){ 
    sleep(1); 
    printf("child got a message: %s\n", shm); 
    sprintf(shm, "%s", "hello, father."); 
    exit(0); 
  }

	sprintf(shm, "%s", "hello, my child"); 
  sleep(2); 
  printf("parent got a message: %s\n", shm);

	return 0;

}
```

在这个过程中，我们先是用mmap方法创建一块恭喜那个内存区域，命名为shm，接着又通过fork这个系统调用创建子进程。从13行～16行代码是子进程的执行逻辑，具体讲，子进程休眠一秒后，从shm中取出一行字符并打印出来，然后又向共享内存中写入了一行消息。

在子进程的执行逻辑之后，是父进程的执行逻辑：父进程先写入一行消息，然后休眠两秒，等待子进程完成读取消息和发消息的过程并退出后，父进程再从共享内存中取出子进程发过来的消息。

得出结果：

```c
$ gcc -o mm mmap_shm.c 
$ ./mm 
child got a message: hello, my child 
parent got a message: hello, father.
```

课程小结：

**一个进程的内存可以分为内核区域和用户区域**。

----

### 04｜深入理解栈：从CPU和函数的视角看栈的管理

#### 函数与栈帧

**栈帧本质是一个函数的活动记录。**当某个函数正在执行时候，它的活动记录就会存在，当函数执行结束时，活动记录也被销毁。

#### 当我们在谈递归时，我门在谈什么

**汉诺塔**问题很好的解释递归问题。一次汉诺塔求解过程我们可以先看到，先创建的帧最后才销毁，后创建的帧最先被销毁，这就是先入后出的规律，也是程序执行时的活跃记录要被叫做栈的原因。

#### 从指令的角度理解栈



#### 栈溢出

----

### 05｜栈的魔法：从栈切换的角度理解进程和协程

#### 什么是执行单元

执行单元是指CPU调度和分派的基本单位，他是一个CPU能正常运行的基本单元。执行单元是可以停下来的，只要能把CPU状态全部保存起来，等到这个执行单元再被调度的时候，就把状态恢复过来就行了。我们把这种保持状态，挂起，恢复执行，恢复状态的完整过程，称为执行单元的调度。

具体说就是常见的执行单元有进程、线程和协程三种。

#### 理解进程和线程

当运行一个可执行程序的时候，操作系统就会启动一个进程。进程会被操作系统管理和调度，被调度的进程就可以独占CPU了。

同一个进程中的线程共享该进程的内存空间，文件表，文件描述符等，它与统一进程的其他线程共享资源分配。出来共享的资源，每个现场也有自己的私有空间，这就是线程的栈。线程在执行函数钓鱼破呢的时候，会在自己的线程栈里创建函数栈帧。

#### 理解协程

协程是比线程更轻量的执行单元，进程和线程的调度是由操作系统负责的，而协程则是由执行单元互相协商进行调度的，所以它的切换发生在用户态。只有前一个协程主动地执行yield函数让出CPU的使用权，下一个协程才能得到调度。

因为程序自己负责协程的调度，多亿大多数时候，我们可以让不那么忙的协程少参与调度，从而提升整个程序的吞吐量，而不是像进程那样，没有繁重任务，也有可能被换进来执行。

















## 硬件篇

### 13｜存储电路：计算机存储芯片的电路结构是怎样的？



















## 自动内存管理

### 18｜Java内存 模型：Java中volatile有什么用？













## 加餐













## 结束语















